###TopK问题
这个问题的实际运用也很多，例如，在搜索引擎中，统计搜索最热门的10个查询词；在歌曲库中统计下载最高的前10首歌等。
从海量数据中寻找最小的K(K一般比较小)个数，首先内存里一次存不下这么多数，即使能存下，如果通过遍历K次找出最小的K个数，时间复杂度也是O(N2)了，所以需要换种思路了。
我们可以利用一个容器先存储前K个数据，然后从剩下的数据中读取下一个数，判断该数是与容器中最大的数的谁大，如果该数较大或相等，侧读取下一个数，如果该数比容器中最大数还小，则删除容器中该最大数，将该数放入容器中，然后读取下一个数...最终容器里存的K个数就是最小的K个数。
我们首先想到的就是用大堆来解决，根的元素就是堆里最大的。其实这里还可以用二叉搜索树，红黑树解决，因为它们的最右节点是最大的。

建堆时间复杂度是O(NS?N)，后面的向下调整也是O(NS?N)，所以这个算法整体的时间复杂度就是O(NS?N)