#### 用两个栈实现队列
题目描述：我们知道队列底层可以用链表实现，方便头删操作。现在我们想用两个栈实现一个队列，完成队列的头删和尾插操作。
其中新元素始终 push 到 栈1 中，重点讨论队列的pop操作。分三种情况。
1. 如果 栈2 是空的，就把 栈1 中的元素依次倒入 栈2 中，就像两个容器倒入一样，这时栈1 中通过尾插进去的元素完成了一次逆序，栈2中栈顶的元素就是我们需要pop掉的队首元素。
2. 如果栈1和栈2都为空，抛出异常，不允许队列进行pop操作。
3. 如果栈2不为空，栈顶的元素就是队列队首元素。

#### 用两个队列实现栈
其中的两个队列有两种状态：
1. 两个队列都为空
2. 其中一个队列为空，另一个不为空

push 操作：
1. 如果q1与q2都为空，那么往q1中插入元素
2. 如果q1不为空（那么q2肯定为空），那么往q1中插入元素（说明q1连续push操作）
3. 如果q1为空，q2不为空，那么往q2中插入元素（q1为空说明进行了一次pop操作）

pop操作：把其中不为空的队列里的前面的元素pop并push到另一个队列，把最后一个元素pop出去

#### 实现一个栈返回最小值的时间复杂度为O(1)
第一种思路使用一个栈：
元素x入栈时，执行一次push(x)，再push(min)，min表示当前栈里最小的元素；
元素出栈时，执行两次pop()，Min() 函数返回栈顶即可，栈的 top() 其实是栈顶第二个元素。
但是这个算法有个缺陷，如果栈底的元素就是整个栈的最小元素，上面每次 push 入栈时重复保存了 最小元素，浪费空间。
第二种思路是用两个栈实现：
元素 x 入栈时，将 x 和 m 栈顶元素做比较，如果 x 小于等于 m.top()，将 x 分别 push 到 s 和 m，否则 x 只 push 到 s（其中 s 栈存数据，m 栈保存当前最小元素）;
元素出栈时，将 s 栈顶元素和 m 栈顶元素做比较，如果 s.top() 等于 m.top()，s 和 m 都执行 pop 操作，否则只执行 s.pop()

#### 判断元素出栈顺序的合法性
判断元素出栈，入栈顺序的合法性。如入栈的序列（1,2,3,4,5），出栈序列为（4,5,3,2,1）
这个题的思路就是，借用一个栈，按照所给的入栈顺序再次入栈，每入栈一个元素，在出栈顺序里判断该元素是否应该出栈了。
如果应该出栈了，就把该元素pop出栈，并偏移指向出栈顺序的下标，然后再判断当前栈顶元素是否可以出栈。
如果栈顶元素不能出栈，并且没有新元素可以push了，那么所给的出栈顺序不合法。如果栈pop空了，或者指向出栈顺序的下标也越界了，那么所给的出栈顺序是合法的。

#### 一个数组实现两个栈
这道题有三个思路：
1. 将数组下标为0的位置作为第一个栈的栈底，将下标为1的位置作为第二个栈的栈底。也就是偶数位放第一个栈的元素，奇数位放第二个栈的元素。
2. 把数组中间位置作为两个栈的栈底，两个栈都向两边增长，当任何一边到达数组起始位置或末尾就扩容。
3. 将数组起始位置作为第一个栈的栈底，将数组末尾作为第二个栈的栈底，当两个栈顶相遇时扩容。